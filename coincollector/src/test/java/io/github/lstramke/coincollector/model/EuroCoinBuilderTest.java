package io.github.lstramke.coincollector.model;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

public class EuroCoinBuilderTest {

	private record BuilderTestcase(
		int year,
        CoinValue value,
        CoinCountry mintCountry,
        CoinDescription coinDescription,
        Mint mint,
        String id,
        String collectionId,
        String expectedId,
        String expectedDescription,
		Class<? extends Exception> expectedException,
		String description
	){
		@Override
		public String toString(){
			return description;
		}
	}

	private static Stream<BuilderTestcase> builderTestcases(){
		return Stream.of(
			new BuilderTestcase(-1, CoinValue.ONE_EURO, CoinCountry.GERMANY, null, Mint.BERLIN, null, "col-a",
                null, null, IllegalStateException.class,"invalid: year too small"
			),
			new BuilderTestcase(EuroCoinBuilder.EURO_COIN_START_YEAR, null, CoinCountry.GERMANY, null, Mint.BERLIN, null, "col-b",
				null, null, IllegalStateException.class, "invalid: null value"
			),
			new BuilderTestcase(EuroCoinBuilder.EURO_COIN_START_YEAR, CoinValue.ONE_EURO, null, null, Mint.BERLIN, null, "col-c",
				null, null, IllegalStateException.class, "invalid: null mintCountry"
			),
			new BuilderTestcase(2020, CoinValue.TWO_EUROS, CoinCountry.GERMANY, null, Mint.MUNICH, null, null,
				null, null, IllegalStateException.class, "invalid: null collectionId"
			),
			new BuilderTestcase(2024, CoinValue.TEN_CENTS, CoinCountry.GERMANY, null, Mint.HAMBURG, null, "col-ok",
				String.format("%s_%s_%d_%s", CoinCountry.GERMANY.name(), CoinValue.TEN_CENTS.name(), 2024, Mint.HAMBURG.name()), 
                "10 Cent Münze aus Deutschland vom Jahr 2024 aus der Prägestätte HAMBURG", null, "valid: autogenerated description and id"
			),
            new BuilderTestcase(2024, CoinValue.TEN_CENTS, CoinCountry.GERMANY, new CoinDescription("manual description"), Mint.HAMBURG, null, "col-ok",
				String.format("%s_%s_%d_%s", CoinCountry.GERMANY.name(), CoinValue.TEN_CENTS.name(), 2024, Mint.HAMBURG.name()), 
                "manual description", null, "valid: manual description and id"
			)
        );
	}

	@ParameterizedTest(name = "{index} - {0}")
	@MethodSource("builderTestcases")
	void testBuild(BuilderTestcase testcase){
		EuroCoinBuilder builder = new EuroCoinBuilder()
			.setYear(testcase.year)
			.setValue(testcase.value)
			.setMintCountry(testcase.mintCountry)
			.setMint(testcase.mint)
			.setCollectionId(testcase.collectionId);

		if (testcase.coinDescription != null){
			builder.setDescription(testcase.coinDescription);
		}
		if (testcase.id != null){
			builder.setId(testcase.id);
		}

		if (testcase.expectedException != null){
			assertThrows(
				testcase.expectedException,
				builder::build,
				"Expected exception for: " + testcase.description
			);
		} else {
		    EuroCoin coin = builder.build();
		    assertNotNull(coin, "coin should be created");
		    assertEquals(testcase.year, coin.getYear());
		    assertEquals(testcase.value, coin.getValue());
		    assertEquals(testcase.mintCountry, coin.getMintCountry());
		    assertNotNull(coin.getDescription(), "description should be present (auto-gen)");
		    assertNotNull(coin.getId(), "id should be present (auto-gen)");
        }
	}
}
