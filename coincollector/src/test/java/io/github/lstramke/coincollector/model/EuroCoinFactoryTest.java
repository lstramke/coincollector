package io.github.lstramke.coincollector.model;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.stream.Stream;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

public class EuroCoinFactoryTest {

	private record FromDbEntryTestcase(
		String id,
		int year,
		int centValue,
		String countryIso,
		String mintMark,
		String description,
		String collectionId,
		boolean sqlExceptionOnAccess,
		String expectedMintMark,
		Class<? extends Exception> expectedException,
		String descriptionText
	){
		@Override
		public String toString(){
			return descriptionText;
		}
	}

	private static Stream<FromDbEntryTestcase> fromDbEntryTestcases(){
		return Stream.of(
			new FromDbEntryTestcase("coin-1", 2002, 100, "DE", "A", "1 Euro MÃ¼nze", "col-1", false, "A", null,
				"valid: proper row creates coin with preserved id"),
			new FromDbEntryTestcase(null, 2002, 100, "DE", "A", "desc", "col-1", false, "A", null,
				"valid: null id -> autogenerated correct id"),
			new FromDbEntryTestcase("   ", 2002, 100, "DE", "A", "desc", "col-1", false, "A", null,
				"valid: empty id -> autogenerated correct id"),
			new FromDbEntryTestcase("coin-2", 1998, 100, "DE", "A", "desc", "col-1", false, null, SQLException.class,
				"invalid: year too small -> wrapped to SQLException with ISE cause"),
			new FromDbEntryTestcase("coin-3", 2002, 999, "DE", "A", "desc", "col-1", false, null, SQLException.class,
				"invalid: unknown coin value -> wrapped to SQLException with IAE cause"),
			new FromDbEntryTestcase("coin-4", 2002, 100, "ZZ", "A", "desc", "col-1", false, null, SQLException.class,
				"invalid: unknown country iso -> wrapped to SQLException with IAE cause"),
			new FromDbEntryTestcase("coin-5", 2002, 100, "DE", "Z", "desc", "col-1", false, null, SQLException.class,
				"invalid: unknown mint mark -> wrapped to SQLException with IAE cause"),
			new FromDbEntryTestcase("coin-5", 2002, 100, "FR", "Z", "desc", "col-1", false, "UNKNOWN", null,
				"valid: unknown mint mark but not German Coin -> mint mark will be UNKNOWN"),
			new FromDbEntryTestcase("coin-6", 2002, 100, "DE", "A", "desc", null, false, null, SQLException.class,
				"invalid: null collection id -> wrapped to SQLException with ISE cause"),
			new FromDbEntryTestcase("ignored", 2002, 100, "DE", "A", "desc", "col-1", true, null, SQLException.class,
				"sql error: ResultSet access throws SQLException and is propagated")
		);
	}

	@ParameterizedTest(name = "{index} - {0}")
	@MethodSource("fromDbEntryTestcases")
	void testFromDataBaseEntry(FromDbEntryTestcase testcase) throws Exception {
		EuroCoinFactory factory = new EuroCoinFactory();

		ResultSet rs = mock(ResultSet.class);

		if (testcase.sqlExceptionOnAccess){
			when(rs.getString(anyString())).thenThrow(new SQLException("rs boom"));
			when(rs.getInt(anyString())).thenThrow(new SQLException("rs boom"));
		} else {
			when(rs.getString("coin_id")).thenReturn(testcase.id);
			when(rs.getInt("year")).thenReturn(testcase.year);
			when(rs.getInt("coin_value")).thenReturn(testcase.centValue);
			when(rs.getString("mint_country")).thenReturn(testcase.countryIso);
			when(rs.getString("mint")).thenReturn(testcase.mintMark);
			when(rs.getString("description")).thenReturn(testcase.description);
			when(rs.getString("collection_id")).thenReturn(testcase.collectionId);
		}

		if (testcase.expectedException != null){
			assertThrows(testcase.expectedException, () -> factory.fromDataBaseEntry(rs),
                "Expected exception was not thrown for: " + testcase.description
            );
		} else {
			EuroCoin coin = factory.fromDataBaseEntry(rs);
			assertNotNull(coin);
			assertEquals(((testcase.id != null && !testcase.id.isBlank()) ? testcase.id : "GERMANY_ONE_EURO_2002_BERLIN"), coin.getId()); //if id cant be correct autogenerate correct
			assertEquals(testcase.year, coin.getYear());
			assertEquals(testcase.centValue, coin.getValue().getCentValue());
			assertEquals(testcase.countryIso, coin.getMintCountry().getIsoCode());
			assertEquals(testcase.expectedMintMark, coin.getMint().getMintMark());
			assertEquals(testcase.collectionId, coin.getCollectionId());
			assertEquals(testcase.description, coin.getDescription().getText());

			verify(rs, times(1)).getString("coin_id");
			verify(rs, times(1)).getInt("year");
			verify(rs, times(1)).getInt("coin_value");
			verify(rs, times(1)).getString("mint_country");
			verify(rs, times(1)).getString("mint");
			verify(rs, times(1)).getString("description");
			verify(rs, times(1)).getString("collection_id");
			verifyNoMoreInteractions(rs);
		}
	}
}
